/*
 * generated by Xtext 2.18.0.M3
 */
package org.xtext.tcc.mydsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.tcc.mydsl.myDsl.Api;
import org.xtext.tcc.mydsl.myDsl.ApiNome;
import org.xtext.tcc.mydsl.myDsl.Associacao;
import org.xtext.tcc.mydsl.myDsl.Atributo;
import org.xtext.tcc.mydsl.myDsl.AtributoTipo;
import org.xtext.tcc.mydsl.myDsl.Entidade;
import org.xtext.tcc.mydsl.myDsl.Greeting;
import org.xtext.tcc.mydsl.myDsl.Model;
import org.xtext.tcc.mydsl.myDsl.MyDslPackage;
import org.xtext.tcc.mydsl.myDsl.Nome;
import org.xtext.tcc.mydsl.myDsl.Operacao;
import org.xtext.tcc.mydsl.services.MyDslGrammarAccess;

@SuppressWarnings("all")
public class MyDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MyDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MyDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MyDslPackage.API:
				sequence_Api(context, (Api) semanticObject); 
				return; 
			case MyDslPackage.API_NOME:
				sequence_ApiNome(context, (ApiNome) semanticObject); 
				return; 
			case MyDslPackage.ASSOCIACAO:
				sequence_Associacao(context, (Associacao) semanticObject); 
				return; 
			case MyDslPackage.ATRIBUTO:
				sequence_Atributo(context, (Atributo) semanticObject); 
				return; 
			case MyDslPackage.ATRIBUTO_TIPO:
				sequence_AtributoTipo(context, (AtributoTipo) semanticObject); 
				return; 
			case MyDslPackage.ENTIDADE:
				sequence_Entidade(context, (Entidade) semanticObject); 
				return; 
			case MyDslPackage.GREETING:
				sequence_Greeting(context, (Greeting) semanticObject); 
				return; 
			case MyDslPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case MyDslPackage.NOME:
				sequence_Nome(context, (Nome) semanticObject); 
				return; 
			case MyDslPackage.OPERACAO:
				sequence_Operacao(context, (Operacao) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     ApiNome returns ApiNome
	 *
	 * Constraint:
	 *     nome=STRING_LIT
	 */
	protected void sequence_ApiNome(ISerializationContext context, ApiNome semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.API_NOME__NOME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.API_NOME__NOME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getApiNomeAccess().getNomeSTRING_LITTerminalRuleCall_0(), semanticObject.getNome());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Api returns Api
	 *
	 * Constraint:
	 *     (nomeApi=ApiNome entidades+=Entidade+)
	 */
	protected void sequence_Api(ISerializationContext context, Api semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Associacao returns Associacao
	 *
	 * Constraint:
	 *     associacao=NOME_ASSOCIACAO
	 */
	protected void sequence_Associacao(ISerializationContext context, Associacao semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ASSOCIACAO__ASSOCIACAO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ASSOCIACAO__ASSOCIACAO));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssociacaoAccess().getAssociacaoNOME_ASSOCIACAOTerminalRuleCall_0(), semanticObject.getAssociacao());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AtributoTipo returns AtributoTipo
	 *
	 * Constraint:
	 *     (tipoP=TIPO_DEFINIDO | tipoE=STRING_LIT)
	 */
	protected void sequence_AtributoTipo(ISerializationContext context, AtributoTipo semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Atributo returns Atributo
	 *
	 * Constraint:
	 *     (nomeAtributo=Nome atributoTipo=AtributoTipo associacao=Associacao operacao=Operacao)
	 */
	protected void sequence_Atributo(ISerializationContext context, Atributo semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ATRIBUTO__NOME_ATRIBUTO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ATRIBUTO__NOME_ATRIBUTO));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ATRIBUTO__ATRIBUTO_TIPO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ATRIBUTO__ATRIBUTO_TIPO));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ATRIBUTO__ASSOCIACAO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ATRIBUTO__ASSOCIACAO));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ATRIBUTO__OPERACAO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ATRIBUTO__OPERACAO));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtributoAccess().getNomeAtributoNomeParserRuleCall_3_0(), semanticObject.getNomeAtributo());
		feeder.accept(grammarAccess.getAtributoAccess().getAtributoTipoAtributoTipoParserRuleCall_7_0(), semanticObject.getAtributoTipo());
		feeder.accept(grammarAccess.getAtributoAccess().getAssociacaoAssociacaoParserRuleCall_11_0(), semanticObject.getAssociacao());
		feeder.accept(grammarAccess.getAtributoAccess().getOperacaoOperacaoParserRuleCall_15_0(), semanticObject.getOperacao());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Entidade returns Entidade
	 *
	 * Constraint:
	 *     (nomeEntidade=Nome atributos+=Atributo+ chavePrimaria=Nome package=Nome)
	 */
	protected void sequence_Entidade(ISerializationContext context, Entidade semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Greeting returns Greeting
	 *
	 * Constraint:
	 *     api=Api
	 */
	protected void sequence_Greeting(ISerializationContext context, Greeting semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.GREETING__API) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.GREETING__API));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGreetingAccess().getApiApiParserRuleCall_1_0(), semanticObject.getApi());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     greetings+=Greeting
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Nome returns Nome
	 *
	 * Constraint:
	 *     nome=STRING_LIT
	 */
	protected void sequence_Nome(ISerializationContext context, Nome semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.NOME__NOME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.NOME__NOME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNomeAccess().getNomeSTRING_LITTerminalRuleCall_0(), semanticObject.getNome());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Operacao returns Operacao
	 *
	 * Constraint:
	 *     opCascada=NOME_OPERACAO
	 */
	protected void sequence_Operacao(ISerializationContext context, Operacao semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.OPERACAO__OP_CASCADA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.OPERACAO__OP_CASCADA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOperacaoAccess().getOpCascadaNOME_OPERACAOTerminalRuleCall_0(), semanticObject.getOpCascada());
		feeder.finish();
	}
	
	
}
